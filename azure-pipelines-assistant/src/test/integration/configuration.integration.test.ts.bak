import * as assert from 'assert';
import * as vscode from 'vscode';
import { ConfigurationService } from '../../services/configurationService';
import { DEFAULT_CONFIGURATION } from '../../models/configuration';

suite('Configuration Integration Tests', () => {
  let configService: ConfigurationService;
  let context: vscode.ExtensionContext;

  setup(async () => {
    // Get the extension context from the test environment
    const extension = vscode.extensions.getExtension('azure-pipelines-assistant.azure-pipelines-assistant');
    if (!extension) {
      throw new Error('Extension not found in test environment');
    }
    
    // Create a mock context for testing
    context = {
      secrets: {
        get: async () => undefined,
        store: async () => {},
        delete: async () => {},
        onDidChange: () => ({ dispose: () => {} })
      },
      subscriptions: [],
      workspaceState: {
        get: () => undefined,
        update: async () => {},
        keys: () => []
      },
      globalState: {
        get: () => undefined,
        update: async () => {},
        keys: () => [],
        setKeysForSync: () => {}
      },
      extensionUri: extension.extensionUri,
      extensionPath: extension.extensionPath,
      asAbsolutePath: (relativePath: string) => vscode.Uri.joinPath(extension.extensionUri, relativePath).fsPath,
      storageUri: vscode.Uri.joinPath(extension.extensionUri, 'storage'),
      globalStorageUri: vscode.Uri.joinPath(extension.extensionUri, 'globalStorage'),
      logUri: vscode.Uri.joinPath(extension.extensionUri, 'logs'),
      extensionMode: vscode.ExtensionMode.Test,
      extension: extension,
      environmentVariableCollection: {
        persistent: true,
        description: 'Test environment variables',
        replace: () => {},
        append: () => {},
        prepend: () => {},
        get: () => undefined,
        forEach: () => {},
        delete: () => {},
        clear: () => {},
        [Symbol.iterator]: function* () {}
      },
      storagePath: vscode.Uri.joinPath(extension.extensionUri, 'storage').fsPath,
      globalStoragePath: vscode.Uri.joinPath(extension.extensionUri, 'globalStorage').fsPath,
      logPath: vscode.Uri.joinPath(extension.extensionUri, 'logs').fsPath,
      languageModelAccessInformation: {
        onDidChange: () => ({ dispose: () => {} }),
        canSendRequest: () => undefined
      }
    } as vscode.ExtensionContext;

    configService = new ConfigurationService(context);
  });

  teardown(() => {
    if (configService) {
      configService.dispose();
    }
  });

  test('should create configuration service', () => {
    assert.ok(configService);
  });

  test('should return default configuration values', () => {
    const config = configService.getConfiguration();
    
    assert.strictEqual(config.refreshInterval, DEFAULT_CONFIGURATION.refreshInterval);
    assert.strictEqual(config.maxRunsPerPipeline, DEFAULT_CONFIGURATION.maxRunsPerPipeline);
    assert.strictEqual(config.showTimestamps, DEFAULT_CONFIGURATION.showTimestamps);
    assert.strictEqual(config.autoRefresh, DEFAULT_CONFIGURATION.autoRefresh);
    assert.deepStrictEqual(config.favoriteProjects, DEFAULT_CONFIGURATION.favoriteProjects);
    assert.deepStrictEqual(config.favoritePipelines, DEFAULT_CONFIGURATION.favoritePipelines);
    assert.strictEqual(config.cacheTimeout, DEFAULT_CONFIGURATION.cacheTimeout);
    assert.strictEqual(config.logLevel, DEFAULT_CONFIGURATION.logLevel);
    assert.strictEqual(config.showWelcomeOnStartup, DEFAULT_CONFIGURATION.showWelcomeOnStartup);
    assert.strictEqual(config.compactView, DEFAULT_CONFIGURATION.compactView);
  });

  test('should validate configuration correctly', () => {
    const validConfig = {
      organization: 'myorg',
      refreshInterval: 30,
      maxRunsPerPipeline: 10,
      showTimestamps: true,
      autoRefresh: true,
      favoriteProjects: [],
      favoritePipelines: [],
      cacheTimeout: 300,
      logLevel: 'info' as const,
      showWelcomeOnStartup: true,
      compactView: false
    };

    const result = configService.validateConfiguration(validConfig);
    assert.strictEqual(result.isValid, true);
    assert.strictEqual(result.errors.length, 0);
  });

  test('should detect invalid configuration', () => {
    const invalidConfig = {
      organization: '-invalid-org-',
      refreshInterval: 5, // Too low
      maxRunsPerPipeline: 100, // Too high
      showTimestamps: true,
      autoRefresh: true,
      favoriteProjects: [],
      favoritePipelines: [],
      cacheTimeout: 30, // Too low
      logLevel: 'info' as const,
      showWelcomeOnStartup: true,
      compactView: false
    };

    const result = configService.validateConfiguration(invalidConfig);
    assert.strictEqual(result.isValid, false);
    assert.ok(result.errors.length > 0);
  });

  test('should handle favorites management', async () => {
    // Test project favorites
    assert.strictEqual(configService.isProjectFavorite('test-project'), false);
    
    // Note: In a real test environment, we would need to mock the workspace configuration
    // For now, we just test that the methods don't throw errors
    try {
      await configService.addProjectToFavorites('test-project');
      await configService.removeProjectFromFavorites('test-project');
    } catch (error) {
      // Expected in test environment without proper VS Code workspace
      assert.ok(error instanceof Error);
    }

    // Test pipeline favorites
    const testPipeline = { projectId: 'proj1', pipelineId: 1, name: 'Test Pipeline' };
    assert.strictEqual(configService.isPipelineFavorite('proj1', 1), false);
    
    try {
      await configService.addPipelineToFavorites(testPipeline);
      await configService.removePipelineFromFavorites('proj1', 1);
    } catch (error) {
      // Expected in test environment without proper VS Code workspace
      assert.ok(error instanceof Error);
    }
  });

  test('should export configuration', async () => {
    try {
      const exported = await configService.exportConfiguration();
      const parsed = JSON.parse(exported);
      
      assert.ok(parsed.exportedAt);
      assert.strictEqual(parsed.version, '1.0');
      assert.ok(typeof parsed.refreshInterval === 'number');
      assert.ok(typeof parsed.maxRunsPerPipeline === 'number');
    } catch (error) {
      // Expected in test environment
      assert.ok(error instanceof Error);
    }
  });
});